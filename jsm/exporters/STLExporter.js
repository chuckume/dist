import{Vector3}from"three";class STLExporter{parse(t,e={}){const o=void 0!==e.binary&&e.binary,r=[];let n,i=0;t.traverse((function(t){if(t.isMesh){const e=t.geometry;if(!0!==e.isBufferGeometry)throw new Error("THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.");const o=e.index,n=e.getAttribute("position");i+=null!==o?o.count/3:n.count/3,r.push({object3d:t,geometry:e})}}));let s=80;if(!0===o){const t=new ArrayBuffer(2*i+3*i*4*4+80+4);n=new DataView(t),n.setUint32(s,i,!0),s+=4}else n="",n+="solid exported\n";const f=new Vector3,l=new Vector3,a=new Vector3,c=new Vector3,u=new Vector3,p=new Vector3;for(let t=0,e=r.length;t<e;t++){const e=r[t].object3d,o=r[t].geometry,n=o.index,i=o.getAttribute("position");if(null!==n)for(let t=0;t<n.count;t+=3)m(n.getX(t+0),n.getX(t+1),n.getX(t+2),i,e);else for(let t=0;t<i.count;t+=3)m(t+0,t+1,t+2,i,e)}return!1===o&&(n+="endsolid exported\n"),n;function m(t,e,r,i,m){f.fromBufferAttribute(i,t),l.fromBufferAttribute(i,e),a.fromBufferAttribute(i,r),!0===m.isSkinnedMesh&&(m.boneTransform(t,f),m.boneTransform(e,l),m.boneTransform(r,a)),f.applyMatrix4(m.matrixWorld),l.applyMatrix4(m.matrixWorld),a.applyMatrix4(m.matrixWorld),function(t,e,r){c.subVectors(r,e),u.subVectors(t,e),c.cross(u).normalize(),p.copy(c).normalize(),!0===o?(n.setFloat32(s,p.x,!0),s+=4,n.setFloat32(s,p.y,!0),s+=4,n.setFloat32(s,p.z,!0),s+=4):(n+="\tfacet normal "+p.x+" "+p.y+" "+p.z+"\n",n+="\t\touter loop\n")}(f,l,a),x(f),x(l),x(a),!0===o?(n.setUint16(s,0,!0),s+=2):(n+="\t\tendloop\n",n+="\tendfacet\n")}function x(t){!0===o?(n.setFloat32(s,t.x,!0),s+=4,n.setFloat32(s,t.y,!0),s+=4,n.setFloat32(s,t.z,!0),s+=4):n+="\t\t\tvertex "+t.x+" "+t.y+" "+t.z+"\n"}}}export{STLExporter};